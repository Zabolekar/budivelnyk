# Very Short Version

If you manually assemble and link the asm code produced by budivelnyk,
add the `-z noexecstack` linker flag.

# Longer Version

## Example

We'll test the following x86_64 code:

```
    .text
    .global main
    .intel_syntax noprefix
main:
    mov     eax, 0xc35bc031
    push    rax
    jmp     rsp
```

Assembling and linking it on a Linux-based or BSD-based system
with GCC or Clang is as easy as:

```sh
cc test.s
```

What does this code do? `0xc35bc031` means:

```
    31 c0          xor eax eax
    5b             pop rbx
    c3             ret
```

We push it on the stack, then start executing it. If we are allowed
to execute code from the stack, the program will exit successfully.
If we are not allowed to do that, the program will segfault.

## Problem

Code generated by `budivelnyk` never requires executable stack and
doesn't care whether it's allowed. So why do we have to think about
executable stack at all? Here's why:

1. On Linux, if a shared object is marked as needing executable stack,
all programs linked against it will have executable stack, too,
whether they want it or not.

2. On some popular Linux distros, e.g. Debian and Ubuntu, executable stack
is the default. Your code will be marked as needing executable stack unless
you opt out (at least the linker warns you, though).

This means: we have to mark our code as *not* needing executable stack,
or it will have executable stack and all programs linked against it will
have executable stack as well, and that will make them less secure and is
frowned upon.

There are two ways to mark it: in the code itself or by using linker
flags. Let's examine both.

## Back to the Example

We have to consider three ways of assembling and linking:

1. With the `-z execstack` option, that makes the stack executable.
2. With the `-z noexecstack` option, that makes the stack non-executable.
3. With the default parameters.

Let's try them out on Debian:

Executable stack:

```
$ cc test.s -z execstack
$ ./a.out 
$ echo $?
0
```

It runs successfully, as one would expect.

Non-executable stack:

```
$ cc test.s -z noexecstack
$ ./a.out 
Segmentation fault
```

It crashes, as expected. As `man lld` says, stack permissions are recorded
in the `PT_GNU_STACK` segment. You can examine them with `readelf`:

```
$ readelf --segments a.out | grep STACK -A 1
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
```

RW means readable and writable. If it were executable, it would be RWE.

So far so good. What happens by default?

```
$ сс test.s
/usr/bin/ld: warning: /tmp/cclFZtjl.o: missing .note.GNU-stack section implies executable stack
/usr/bin/ld: NOTE: This behaviour is deprecated and will be removed in a future version of the linker
$ ./a.out
$ echo $?
0
```

As we see, by default, cc produces executable stack, but prints a 
warning. The warning suggests that we add the following line to our
asm code:

    .section .note.GNU-stack

If we do that, cc produces non-executable stack when called without
additional parameters, and there is no warning anymore. The flags
`noexecstack` and `execstack` work like they did before.

So there are two solutions: using the `noexecstack` flag or adding the
`.section .note.GNU-stack` line. When using Debian on x86_64, there
doesn't seem to be a difference. Using the flag makes the source code
a little bit more concise, but the advantage is neglegible. Adding the
line makes calling cc manually a little bit easier, but we don't call it
manually that often. So which one is better?

## What Happens on Other Systems

Other Linux distributions may configure their linkers differently so that
they ignore `.section .note.GNU-stack`. Other operating systems might
choose to ignore the `PT_GNU_STACK` segment, too. 

Examples (tested in 2025, though not always with the latest version):

- On Alpine and Arch, `cc test.s` behaves like `cc test.s -z noexecstack`.
- Same on Fedora, but, in addition, `cc test.s -z execstack` produces
a warning.
- On OpenBSD, there will be no warnings and the stack will be
non-executable no matter which flags were used and what the `PT_GNU_STACK`
segment looks like.
- On FreeBSD, the beheviour depends on the sysctl variable
`kern.elf64.nxstack`: if it's 1, code compiled with `-z execstack` will
have executable stack and code compiled with default parameters or with
`-z noexecstack` will have non-executable stack. If it's 0, then the same
executables will always have executable stack. There will be no warnings.
- Debian on i686 hardware is the weirdest: it behaves exactly like Debian
on x86_64 hardware, including warning you by default if there is no
`.section .note.GNU-stack`. The RW/RWE flags are the same, too. But the
stack is always executable. (To test that, you'll have to adjust the code
slightly: eax instead of rax and esp instead of rsp).
- On CentOS Linux 7, which is discontinued but still in use, code without
`.section .note.GNU-stack` compiled with default parameters has executable
stack and doesn't even warn. Using either `.section .note.GNU-stack` or
`-z noexecstack` makes stack non-executable.

## Conclusion

As you see, `.section .note.GNU-stack` will mostly be ignored and it
makes sense to always use the linker flag. Sometimes the flag will be
ignored, too, but that's out of our control.

Because we use the linker flag, we might as well not add the line. The
only consequence will be that whoever assembles the code manually will
have to add the flag, too. On a system where it matters they likely
will be warned if they don't. In some rare cases, like when using an
EOL CentOS system, they won't get a warning. In a project intended
for production use, it would make sense for us to be more cautious.
But it's fair to assume that for someone who runs a hobby bf to asm
compiler on an eleven years old system preventing the execution of
malicious code from the stack is low priority.
